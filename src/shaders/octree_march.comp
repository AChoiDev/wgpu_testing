
#version 460 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 2) uniform Frame {
    vec3 pos;
      int p0;
    vec3 right;             
      int p1;
    vec3 up;                
      int p2;
    vec3 forward;           
      int p3;
    float cotanHalfFov;
      int p5; int p6; int p7;
    ivec2 renderResolution;
      int p8; int p9;
};

layout(set = 0, binding = 0, r32f) uniform image2D depth;
layout(set = 0, binding = 3, r16ui) uniform readonly uimage3D octreeTexture;
layout(set = 0, binding = 4, r16ui) uniform readonly uimage3D indexMap;


ivec3 interCoords(ivec3 coords) {
    return abs(coords) * 2 + (sign(coords) - ivec3(1)) / 2;
}

// CHUNK DATA LENGTH
const int CDL = 13 * 3;

int getMapIndex(ivec3 chunkWorldCoords) {
  return int(imageLoad(indexMap, interCoords(chunkWorldCoords)).r);
}

ivec3 getChunkDataCoords(int index) {
  return ivec3(index % CDL, (index / CDL) % CDL, index / (CDL * CDL)) * 18;
}

vec2 getUV(ivec2 invoc) {
    vec2 resolution = vec2(renderResolution);
    float ratio = resolution.x / resolution.y;

    vec2 pixelCoords =  vec2(invoc) + vec2(0.5);
    
    return (2.0 / resolution.y) * pixelCoords - vec2(ratio, 1.0);
}

const int fiveBitMask = (1 << 5) - 1;

int getNextChild(ivec3 tFloorInt, int cp, ivec3 chunkDataCoords) {
    ivec3 innerCoords = 
        (ivec3((cp) & fiveBitMask, (cp >> 5) & fiveBitMask, (cp >> 10) & fiveBitMask) << 1) + tFloorInt;

    ivec3 coords = innerCoords + chunkDataCoords;

    uvec4 imgVal = imageLoad(octreeTexture, coords);

    return int(imgVal.r);
}

vec3 getRayDirection(ivec2 invoc) {
    vec3 baseDir = normalize(vec3(getUV(invoc), cotanHalfFov));

    return baseDir.x * right + baseDir.y * up + baseDir.z * forward;
}

struct RayLevel{ 
    vec3 t;
    int cp;
};

const int MAG = 6;
const int NULL_VALUE = (1 << 16) - 1;

float minComp(vec3 value) {
    return min(min(value.x, value.y), value.z);
}

vec3 rayTreeTraverse(vec3 origin, vec3 dir) {

    ivec3 chunkWorldCoords = ivec3(0);
    RayLevel rlStack[MAG];
    rlStack[0].t = origin / 16.0; // fix this, it's 2^(MAG - 1)

    vec3 corner = step(vec3(0.0), dir);
    vec3 invDir = vec3(1.0 / dir.x, 1.0 / dir.y, 1.0 / dir.z);

    int level = 0;
    vec3 dynEnd = origin;

    ivec3 chunkDataCoords = getChunkDataCoords(getMapIndex(chunkWorldCoords));

    for (int i = 0; i < 999; i++) {
        if (level == -1) {

          chunkWorldCoords += ivec3(floor(rlStack[0].t * 0.5));
          int index = getMapIndex(chunkWorldCoords);
          if (index == ((1 << 16) - 1)) {
            break;
          }
          chunkDataCoords = getChunkDataCoords(index);
          rlStack[0].t = mod(rlStack[0].t, vec3(2.0));

          level += 1;
        }

        if (level == MAG - 1) {
            break;
        }

        if (any(greaterThanEqual(rlStack[level].t, vec3(2.0))) ||
            any(lessThanEqual(rlStack[level].t, vec3(0.0)))) {
            level -= 1; // pop the stack
            continue;
        }

        vec3 tFloorFloat = floor(rlStack[level].t);
        vec3 tFract = rlStack[level].t - tFloorFloat;

        int nextChild = getNextChild(ivec3(tFloorFloat), rlStack[level].cp, chunkDataCoords);
        rlStack[level + 1].t = tFract * 2.0;
        rlStack[level + 1].cp = nextChild;

        vec3 tDelta = dir * (minComp((corner - tFract) * invDir) + 0.0001);
        rlStack[level].t += tDelta;

        level += 1;

        if (nextChild == NULL_VALUE) {
            level -= 1;
            dynEnd += tDelta * pow(2.0, float(MAG - level - 1));
        }
    }

    return dynEnd;
}

void main() {
    ivec2 invoc = ivec2(gl_GlobalInvocationID.xy);

    if (invoc.x >= renderResolution.x || invoc.y >= renderResolution.y) {
      return;
    }

    vec3 rayDir = getRayDirection(invoc);

    vec3 rayEnd = rayTreeTraverse(pos, rayDir);

    float rayLength = length(rayEnd - pos);

    imageStore(depth, invoc, vec4(rayLength));
}