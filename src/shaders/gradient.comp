#version 460 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, r11f_g11f_b10f) uniform image2D outputColor;
layout(set = 0, binding = 1, r8ui) uniform readonly uimage3D map;

//p1 => padding1
layout(set = 0, binding = 2) uniform Frame {
    vec3 right;             
      int p1;
    vec3 up;                
      int p2;
    vec3 forward;           
      int p3;
    float cotanHalfFov;     
      vec3 p4;
};

vec3 getRayDirection(vec3 lookAt, ivec2 pixelCoords) {
    vec2 resolution = imageSize(outputColor);
    float ratio = resolution.x / resolution.y;

    vec3 baseDir = normalize(
      vec3((2.0 / resolution.y) * vec2(pixelCoords) - vec2(ratio, 1.0), cotanHalfFov)
    );

    return baseDir.x * right + baseDir.y * up + baseDir.z * forward;
}

float mincomp(vec3 value) {
    return min(min(value.x, value.z), value.y);
}

bool insideBox3D(vec3 v, vec3 bottomLeft, vec3 topRight) {
    vec3 s = step(bottomLeft, v) - step(topRight, v);
    return (s.x * s.y * s.z) == 1.0; 
}

vec3 PlaneMarch(vec3 p0, vec3 d) {
  float t = 0;
  int i = 0;
  
  vec3 invDir = vec3(1.0 / d.x, 1.0 / d.y, 1.0 / d.z);
  vec3 corner = step(0, d);

  while (i <= 200) {
    i++;
    vec3 p = p0 + d * t;

    if (!insideBox3D(p, vec3(0), vec3(32))) {
      return p;
    }

    ivec3 mapPos = ivec3(p);
    if (imageLoad(map, mapPos).r != 0) {
      return p;
    }
    
    vec3 deltas = (corner - fract(p)) * invDir;
    t += mincomp(deltas) + 0.001;
  }

  return vec3(0);
}

void main() {
    ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);

    vec4 baseColor = vec4((pixel_pos.x % 2 == 0)? 0.0 : 30.4, 0.01, 20.010, 1.0);
    vec4 colorResult = baseColor;


    vec3 endPos = PlaneMarch(vec3(15), getRayDirection(vec3(0.0, 0.0, 1.0), pixel_pos));

    float rayLength = length(endPos - vec3(15));
    colorResult = vec4(exp(-rayLength * 0.205));
    
    imageStore(outputColor, pixel_pos, colorResult);
    // imageStore(outputColor, pixel_pos, vec4(up.xyz, 1.0));
}