#version 460 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
//layout(set = 0, binding = 0, r8ui) uniform readonly uimage3D map;

//p1 => padding1
//TODO: Rename this to frame
layout(set = 1, binding = 0) uniform Frame {
    vec3 pos;
      int p0;
    vec3 right;             
      int p1;
    vec3 up;                
      int p2;
    vec3 forward;           
      int p3;
    float cotanHalfFov;     
      vec3 p4;
};

layout(set = 2, binding = 0, r16ui) uniform readonly uimage3D sumMap;
layout(set = 2, binding = 1, r32f) uniform image2D outputDepth;
layout(set = 2, binding = 2) uniform utexture3D monoBitMap;
layout(set = 2, binding = 3) uniform sampler monoBitMapSampler;


vec3 getRayDirection(vec3 lookAt, ivec2 pixelCoords) {
    vec2 resolution = imageSize(outputDepth);
    float ratio = resolution.x / resolution.y;

    vec3 baseDir = normalize(
      vec3((2.0 / resolution.y) * vec2(pixelCoords) - vec2(ratio, 1.0), cotanHalfFov)
    );

    return baseDir.x * right + baseDir.y * up + baseDir.z * forward;
}

int getBitIndex(ivec3 coords) {
  return 
      (coords.x & 1) 
    | ((coords.y & 1) << 1) 
    | ((coords.z & 1) << 2);
}

uint extractMonoBitMap(ivec3 coords, int lod) {
  int bitIndex = getBitIndex(coords);

  uint texelValue = texelFetch(usampler3D(monoBitMap, monoBitMapSampler), coords >> 1, lod).r;
  
  //get the nth bit
  return (texelValue >> bitIndex) & 1;
}
float mincomp(vec3 value) {
    return min(min(value.x, value.z), value.y);
}

bool insideBox3D(vec3 v, vec3 bottomLeft, vec3 topRight) {
    vec3 s = step(bottomLeft, v) - step(topRight, v);
    return (s.x * s.y * s.z) == 1.0; 
}

bool checkVoxel(ivec3 coords, int lod) {
  return extractMonoBitMap(coords >> lod, lod) == 1;
}

vec3 PlaneMarch(vec3 p0, vec3 d, out bool hit) {
  hit = false;
  float t = 0;
  int i = 0;
  
  vec3 invDir = vec3(1.0 / d.x, 1.0 / d.y, 1.0 / d.z);
  vec3 corner = step(0, d);

  while (i <= 200) {
    i++;
    vec3 p = p0 + d * t;

    if (!insideBox3D(p, vec3(0), vec3(32))) {
      return p;
    }

    if (checkVoxel(ivec3(p), 0)) {
      hit = true;
      return p;
    }
    
    vec3 deltas = (corner - fract(p)) * invDir;
    t += mincomp(deltas) + 0.001;
  }

  return vec3(0);
}



void main() {
    ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);

    bool hit;
    vec3 endPos = PlaneMarch(pos, getRayDirection(vec3(0.0, 0.0, 1.0), pixel_pos), hit);
    if (!hit) {
      imageStore(outputDepth, pixel_pos, vec4(40.0));
      return;
    }

    float rayLength = length(endPos - vec3(15));

    imageStore(outputDepth, pixel_pos, vec4(rayLength));
}

